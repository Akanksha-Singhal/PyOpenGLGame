{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import pygame\n",
    "from pygame.locals import *\n",
    "from math import *   \n",
    "from OpenGL.GL import *\n",
    "from OpenGL.GLU import *\n",
    "import time\n",
    "import random\n",
    "import pygame.freetype \n",
    "\n",
    "\n",
    "class Drop:\n",
    "    \n",
    "    def __init__(self, cx, cy, r, num_segments, flag, gameDisplay):\n",
    "        self.cx = cx\n",
    "        self.cy = cy\n",
    "        self.r  = r\n",
    "        self.num_segments = num_segments\n",
    "        self.flag = flag\n",
    "        self.color1 = int(random.randrange(0, 10, 3)) \n",
    "        self.color2 = int(random.randrange(0, 10, 3)) \n",
    "        self.color3 = int(random.randrange(0, 10, 3)) \n",
    "        \n",
    "        \n",
    "    def drawCircle(self):\n",
    "        if self.flag==0:\n",
    "           \n",
    "            glPolygonMode( GL_FRONT, GL_FILL )\n",
    "            glColor3f(self.color1/10, self.color2/10, self.color3/10 )\n",
    "            \n",
    "            glBegin(GL_POLYGON)            \n",
    "            for ii in range(0, self.num_segments):\n",
    "                theta = 2.0 * 3.1415926 * (ii) / (self.num_segments);#get the current angle \n",
    "                x = self.r * cos(theta); #calculate the x component \n",
    "                y = self.r * sin(theta); #calculate the y component \n",
    "    \n",
    "                glVertex2f(x + self.cx, y + self.cy); #output vertex \n",
    "            \n",
    "            glEnd()\n",
    "   \n",
    "   \n",
    "        \n",
    "def draweRect(x, y, width, height, c1, c2, c3):\n",
    "    #glClear(GL_COLOR_BUFFER_BIT);\n",
    "    glColor3f(c1,c2,c3);\n",
    "    glLineWidth(30);\n",
    "    \n",
    "    glBegin(GL_POLYGON);\n",
    "    glVertex2f(x-width/2,y+height/2);\n",
    "    glVertex2f(x+width/2,y+height/2);\n",
    "    glVertex2f(x+width/2,y-height/2);\n",
    "    glVertex2f(x-width/2,y-height/2);\n",
    "    glEnd();\n",
    "     \n",
    "\n",
    "    \n",
    "def river(height, circle_height, flag, color):\n",
    "    factor = 0.2\n",
    "    glClear(GL_COLOR_BUFFER_BIT);\n",
    "    \n",
    "    glPolygonMode( GL_FRONT_AND_BACK, GL_FILL )\n",
    "    glColor3f(color[0], color[1], color[2] )\n",
    "    glBegin(GL_POLYGON);\n",
    "      \n",
    "    #glBegin(GL_LINE_STRIP);\n",
    "    for x in range( int(-3.0 / factor), int(3.0 / factor) ):\n",
    "        if x!=0:\n",
    "            #0.09\n",
    "            glVertex2f((x*factor), 0.09*sin(x)+height);\n",
    "            #0.0005\n",
    "            x += 0.0005\n",
    "            \n",
    "    glVertex2f(3.0 / factor, -3); #output vertex \n",
    "    glVertex2f(3, -3); #output vertex\n",
    "    \n",
    "    glVertex2f(-3, -3.0 ); #output vertex \n",
    "    glVertex2f(-3, -3/ factor); #output vertex\n",
    "\n",
    "    glEnd()\n",
    "\n",
    "def main():\n",
    "    pygame.init()\n",
    "    display = (800,600)\n",
    "    gameDisplay = pygame.display.set_mode(display, DOUBLEBUF|OPENGL)\n",
    "    \n",
    "\n",
    "    gluPerspective(45, (display[0]/display[1]), 0.1, 50.0)\n",
    "    glTranslatef(0.0,0.0, -5)\n",
    "    \n",
    "    #INITIALISE HEIGHTS AND POSITION\n",
    "    drop_height = 2.7\n",
    "    drop_radius = 0.26\n",
    "    drop_falling_speed = 0.0189\n",
    "    river_height = -1.5\n",
    "    \n",
    "    bar_x = 0\n",
    "    bar_y = -0.125\n",
    "    bar_width =2\n",
    "    bar_height = 0.25\n",
    "    \n",
    "    drops = []\n",
    "    flag = 0\n",
    "    \n",
    "    river_color = [0.2 , 0.5, 0.5]\n",
    "    game_over_height = 1\n",
    "    score = 0\n",
    "    seed = 30\n",
    "    \n",
    "    # GAME\n",
    "    while True:\n",
    "        \n",
    "        # WHEN THE GAME ENDS DISPLAY SCORE\n",
    "        if river_height>=game_over_height:\n",
    "            screen = pygame.display.set_mode((800, 600), DOUBLEBUF)\n",
    "            GAME_FONT = pygame.freetype.Font(None, 24)\n",
    "            running =  True\n",
    "\n",
    "            while running:\n",
    "                for event in pygame.event.get():\n",
    "                    if event.type == pygame.QUIT:\n",
    "                        running = False\n",
    "                        pygame.quit()\n",
    "\n",
    "                #screen.fill((255,255,255))\n",
    "                # You can use `render` and then blit the text surface ...\n",
    "                text_surface, rect = GAME_FONT.render(\"Game Over!\", (255, 255, 255))\n",
    "\n",
    "                screen.blit(text_surface, (350, 250))\n",
    "                # or just `render_to` the target surface.\n",
    "                GAME_FONT.render_to(screen, (350, 300), \"Score : \"+str(score), (255, 255, 255))\n",
    "\n",
    "                pygame.display.flip()\n",
    "                \n",
    "\n",
    "            \n",
    "        # WHILE THE GAME IS BEING PLAYED SHOW THE GAME SCREEN\n",
    "        for event in pygame.event.get():\n",
    "            if event.type == pygame.QUIT:\n",
    "                pygame.quit()\n",
    "                quit()\n",
    "            elif event.type == KEYDOWN and event.key == K_LEFT:\n",
    "                if bar_x >= -3:\n",
    "                    bar_x = bar_x -0.5\n",
    "            elif event.type == KEYDOWN and event.key == K_RIGHT:\n",
    "                if bar_x <= 3:\n",
    "                    bar_x = bar_x +0.5\n",
    "            elif event.type == KEYDOWN and event.key == K_UP :\n",
    "                if bar_y <= 2:\n",
    "                    bar_y = bar_y +0.5\n",
    "            elif event.type == KEYDOWN and event.key == K_DOWN :\n",
    "                if bar_y - 0.5 >=river_height:\n",
    "                    bar_y = bar_y - 0.5\n",
    "            \n",
    "                \n",
    "        #glRotatef(1, 12.5, 0.01, 0)\n",
    "        glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT)\n",
    "        \n",
    "        #DISPLAY THE RIVER\n",
    "        river(river_height, drop_height, flag, river_color)\n",
    "        \n",
    "        #RANDOM DROP LOCATIONS\n",
    "        x=[-2.1, -0.9, 0.3, 0.9, 2.1]\n",
    "        l=[1,2,3,4,5]\n",
    "        random.seed(seed)\n",
    "        seed =+1\n",
    "        \n",
    "        # GAME \n",
    "        for i in range(0,5):\n",
    "            x_c = random.choice(x) \n",
    "            h =int(random.choice(l))\n",
    "            l.remove(h)\n",
    "            \n",
    "            drops.append(Drop(x_c , drop_height-0.7*h, drop_radius, 100, flag, gameDisplay))\n",
    "            if(drops[i].cy > river_height):                \n",
    "                drops[i].cy -= drop_falling_speed\n",
    "                drops[i].drawCircle()\n",
    "                #COLLISION DETECTION\n",
    "                if drops[i].cy <= river_height+0.1 or (bar_x-1 <=drops[i].cx<= bar_x+1 and bar_y-0.125 <= drops[i].cy-drops[i].r <= bar_y+0.125):\n",
    "                    #COLLISION OF DROP WITH BAR\n",
    "                    if bar_x-1 <=drops[i].cx<= bar_x+1 and bar_y-0.125 <= drops[i].cy-drops[i].r <= bar_y+0.125:\n",
    "                        score +=1\n",
    "                    #COLLISION OF DROP WITH RIVER\n",
    "                    if drops[i].cy <= river_height+0.1:\n",
    "                        river_color = [drops[i].color1/10, drops[i].color2/10, drops[i].color3/10]\n",
    "                        river_height +=0.03\n",
    "                        bar_y +=0.03  \n",
    "                    #DELETE THE DROP \n",
    "                    del drops[i]\n",
    "                    #INSERT A NEW THE DROP \n",
    "                    drops.insert(i, Drop(-1.9+0.9*i , 2.9, drop_radius, 100, flag, gameDisplay))\n",
    "                pass\n",
    "          \n",
    "        # DISPLAY THE BAR\n",
    "        draweRect(bar_x, bar_y, bar_width, bar_height, 153/255, 98/255, 4/255)\n",
    "        \n",
    "        # DISPLAY THE SIDE BAR FOR MAX LEVEL\n",
    "        draweRect(-2.5, game_over_height,0.5, 0.125 ,0.5, 0.35, 0.05)\n",
    "        draweRect(2.5, game_over_height, 0.5, 0.125, 0.5, 0.35, 0.05)\n",
    "        \n",
    "      \n",
    "           \n",
    "        pygame.time.wait(10)\n",
    "\n",
    "        pygame.display.flip()     \n",
    "        \n",
    "\n",
    "main()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.6.4"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
